import { XMLParser } from 'fast-xml-parser';
import type { Database, PlayerTimes } from '../types';

const parser = new XMLParser({
  ignoreAttributes: false,
  attributeNamePrefix: '',
});

function iterate3<T>(tab: T[], fn: (a: T, b: T, c: T) => void): void {
  const num = tab?.length || 0;
  for (let i = 0; i < num; i += 3) {
    fn(tab[i], tab[i + 1], tab[i + 2]);
  }
}

function iterate2<T>(tab: T[], fn: (a: T, b: T) => void): void {
  const num = tab?.length || 0;
  for (let i = 0; i < num; i += 2) {
    fn(tab[i], tab[i + 1]);
  }
}

export function parseAdaptive(xmlText: string, database: Database, playertimes?: PlayerTimes): boolean {
  const xml = parser.parse(xmlText);
  if (!xml) return false;

  const tracklist = xml.AiAdaptation.aiAdaptationData;
  let added = false;

  iterate3(tracklist, (_trackindex: any, trackkey: any, trackvalue: any) => {
    const trackid = trackkey[1]?.toString();
    if (!trackid) return;

    iterate3(trackvalue, (_classindex: any, classkey: any, classcustom: any) => {
      const classid = classkey[1]?.toString();
      if (!classid) return;

      const playerentries = classcustom[1];
      const aientries = classcustom[2];

      if (playertimes && playerentries && playerentries.length > 0) {
        const class_pt = playertimes.classes[classid] || { tracks: {} };
        playertimes.classes[classid] = class_pt;
        const track_pt = class_pt.tracks[trackid] || { playertime: undefined };
        class_pt.tracks[trackid] = track_pt;

        let mintime = 1000000;
        iterate2(playerentries, (_playerindex: any, playercustom: any) => {
          const playertime = parseFloat(playercustom[1]);
          mintime = Math.min(playertime, mintime);
        });
        track_pt.playertime = mintime;
      }

      if (aientries && aientries.length > 0) {
        const class_db = database.classes[classid] || { tracks: {} };
        const track_db = class_db.tracks[trackid] || { ailevels: {} };

        iterate3(aientries, (_aiindex: any, aikey: any, aicustom: any) => {
          const aitime = parseFloat(aicustom[1][1]);
          // filter out values that were generated by the tool/manual
          if (!aitime.toString().match(/\.\d\d$/)) {
            return;
          }

          const ailevel = parseInt(aikey[1]);

          class_db.minAI = Math.min(ailevel, class_db.minAI || ailevel);
          class_db.maxAI = Math.max(ailevel, class_db.maxAI || ailevel);

          track_db.minAI = Math.min(ailevel, track_db.minAI || ailevel);
          track_db.maxAI = Math.max(ailevel, track_db.maxAI || ailevel);

          const times = track_db.ailevels[ailevel] || [];
          track_db.ailevels[ailevel] = times;

          const found = times.includes(aitime);
          if (!found) {
            added = true;
            times.push(aitime);
          }
        });

        if (track_db.maxAI) {
          class_db.tracks[trackid] = track_db;
          database.classes[classid] = class_db;
        }
      }
    });
  });

  return added;
}